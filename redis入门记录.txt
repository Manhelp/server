redis记录

列表类型：
lpush key val1 val2 ... 向列表key左边一次加入元素val1，val2
rpush key val1 val2 ... 向列表key右边一次加入元素val1，val2

llen key 显示列表元素个数

lrange key start stop  	获取从start开始到stop结束间的元素（包含两端），redis的起始索引为0
			lrange中的索引如果为负数表示从右边开始查找
			如果start在stop后则返回空
			如果stop大于实际索引范围则返回从右边开始的实际数量的值
						
lrem key count value 	删除表中前count个值为value的元素， 返回实际删除值的个数
			count > 0 表示从左边开始删除count个值为value的元素
			count < 0 表示从右边开始删除count个值为value的元素
			ocunt = 0 表示删除表中所有值为value的元素
						
						
lindex key index 	返回指定列表key中 index位置的值，index为负数表示从起始在右边
lset key index value 	设置列表key中index位置的值为value, index为负数表示从起始在右边

ltrim key start end 	删除指定范围之外的所有元素, 范围使用和lrange一样

linsert key before|after pivot value 在列表key中查找值为pivot的元素在它的before或者after插入一个值为value的元素
										命令返回插入后列表元素个数

rpoplpush source destination 	这个命令组合了两个命令的操作，执行rpop从列表source右端弹出一个元素然后将其lpush
				到列表destination的左端，返回移动元素的值
								
集合类型：
	集合类型是一种无序，元素不重复的存储结构，存储的key最多2^32-1个。

sadd key member [member...] 	向集合key添加一个或多个元素，如果key不存在则会自动创建，如果集合中已存在元素则忽略
				命令返回真实加入到集合中的元素个数
srem key member [member...] 	从集合中删除一个或多个元素,不存在的元素将忽略，并返回成功删除的个数。

smembers key 			获得集合key中的所有元素

sismember key member 		判断元素是否正集合key中,存在时返回1,值不存在或者键不存在都返回0。

集合相关运算：
sdiff key [key...] 		集合key对多个集合进行差集运算,返回集合key与其他集合不相同的元素
sinter key [key...] 		集合key对多个集合进行交集运算，返回存在于集合key中且存在于其他集合的元素

scard key 			获得集合中的元素个数

sdiffstore destination key [key...] 	用key集合和多个集合进行差集运算，并把结果存在destination集合中
sinterstore destionation key [key...] 	用key集合和多个集合进行交集运算，并把结果存在destination集合中
sunionstore destionation key [key...] 	用key集合和多个集合进行并集运算，并把结果存在destination集合中

srandmember key [count] 	随机从集合中获取一个元素或多个元素，count>0:如count小于集合最大元素个数则随机返回
				count个不同元素，否则返回集合中所有元素；count<0:随机从集合中取出的count个元素有
				可能相同。

spop key 			从集合中弹出一个值,由于集合类型是无序的所以会随机弹出一个元素。


有序集合类型：
	有序集合中集合的基础上关联了一个分数，因此除了集合的基本熟悉外还可以根据分数做相关操作。
	有序集合使用散列表和跳跃表实现所以取集合中间的数据速度也非常快O(log(N).有序集合比列表更耗费内存。

zadd key score member [score member...] 	在有序集合中加入一个元素和分数，如果这个集合中存在这个元素则使用新
						的分数替换原来的分数，否则插入到集合中。命令返回新加入到集合元素个
						数。 
						分数不仅支持整数还支持双精度浮点数，其中+inf,-inf分别表示正负无穷。

zscore key member 		获得有序集合key中member值的分数

zrange key start stop [WITHSCORE] 	从小到大顺序返回索引从start到stop之间的所有元素（包含两端），start和stop的
					使用和lrange相似。如-1表示从后向前查找。如果想获得元素和分数时要加上
					WITHSCORE参数。该命令时间复杂度为O(logn+m)其中n为有序集合基数，m为返回元素
					个数。

zrevrange key start stop [WITHSCORE] 	使用方法和zrange一样，区别时按照从大到小顺序返回元素。

zrangebyscore key min max [WITHSCORE] [LIMIT offset count] 	获得指定分数范围的元素，从小到大返回min和max间的
								元素（包含min和max）。
例子：
zrangebyscore key scoreboard 80 100 返回分数 80 <= score <= 100 的所有元素
zrangebyscore key scoreboard 80 (100 返回分数 80 <= score < 100 的所有元素
zrangebyscore key scoreboard 80 +inf 返回分数 80 <= score <正无穷 的所有元素
zrevranagebyscore key scoreboard 100 0 limit 0 3 返回分数小于或等于100的前三个人


zincby key incrememt member 	增加一个元素的分数返回值是更改后的分数, incrememt小于0表示减分

zcard key 	返回集合中元素个数

zcount key min max 	返回指定分数范围内的元素

zrem key member [member...] 	删除一个或多个元素，返回成功返回的元素数量

zremrangebyrank key start stop 按照元素分数从小到大顺序删除处在指定排名范围内的所有元素，并返回删除元素的数量

zrank key member  	按照元素从小到大顺序获得指定嗯原书的排名(从0开始，即分数最小的元素排名为0）

zrevrank key member  	和上面命令相似区别是 分数最大的元素排名为0

zinterstore destination numkeys key [key...] [WEIGHTS weights [weight...]] [AGGERGATE  SUM|MIN|MAX] 
	该命令用于计算多个有序集合的交集并将结果存储中destination键中，返回destination键中的元素个数,des键元素的分数时由AGGREGATE参数决定的。 SUM：des元素的分数时每个参与计算的集合中该元素分数的和。MIN：参与计算集合中元素分数的最小值。MAX：参与运算元素分数的最大值。

	WEIGHTSK参数可设置每个集合的权重，每个集合中计算元素的分数会被乘上该集合的权重


				
进阶话题：
事务
	Redis的事务时一组命令的集合。事务同命令一样都是Redis的最小执行单位，一个事务要么都执行要么都不执行。
示例：
	multi
	set key value
	set key
	errorcommand key
	exec

	multi命令向Redis说明一下的是一组名，只要其中一个命令出错exec命令会直接返回错误连正确的语句都不会执行。

watch 	watch命令科研监控一个或者多个键，一旦其中的agiel键被修改或者删除，之后的事务都不会执行。监控一直持续
	到exec命令（事务中的命令时中exec之后从执行的，所以在multi命令后科研修改瓦特成监控的键值）。exec执行后
	会取消对所有键的监控，如果不执行事务中的命令也可以使用unwatch来取消监控。
示例：
	set key 1
	watch key
	set key 2 
	multi 
	set key 3
	exec
	get key --> 返回2 因为监控键中事务执行前被修改了，set key 2 修改了被监控的键，所以set key 3将不会执行。

expire 	key seconds 指定key中seconds秒后失效，命令中的seconds参数表示键的生存时间，单位时秒，
示例：
	set key 123
	expire key 900 --> expire返回1表示设置成功，0表示键不存在或者设置失败。
	ttl key --> 返回剩余时间

ttl key 	返回键的剩余时间（多久时间会被删除），键不存在或键没有设置生存时间即永久时返回-1
persist key 	取消键的生存时间设置。除了这个命令外使用set或者getset命令为键复制也会同时清除键的生存时间。

pexpire key ms 	毫秒级的生存期设置
pttl key 	返回毫秒级生存期设置剩余时间

expireat key unixtime	设置key中unixtime秒后失效 
pexpireat key unixtime_ms	设置key中unixtime毫秒时间失效


	在实际开发中发现很难为缓存键设置合理的生存时间，为此科研显示Redis能够使用的最大内存，并让Redis按照一定的鬼子淘汰不需要的缓存键，这种方式在只将Redis用作缓存戏台时非常使用。
	具体设置方法：
	修改配置文件的maxmemory参数，显示Redis的最大可用内存大小（单位时字节），当超出了这个限制时Redis会依据
	maxmemory-policy参数指定的策略来删除不需要的键，直到Redis占用的内存小于指定内存。
	

sort key 	把键为key的列表、有序集合、无序集合进行排序
		sort还可以通过ALPHA参数实现字典顺序排序非数字元素，如：sort mylist ALPHA
		DESC 参数实现从大到小排序，如：sort mylist DESC
		LIMIT参数可以限制返回的范围，如：sort mylist DESC LIMIT 1 2 
		by 参考键 参数，如:sort mylist by post:*->time DESC sort命令会读取mylist值作为post:*中的*,然后取
		post:1散列表中的time字段并以此决定mylist列表的元素顺序。 

持久化
	持久化有两种方式，1、rdb快照方式，通过redis.conf中的save配置进行设置，如：save 900 1 表示900秒内发生一个键
	的更改就进行快照，快照的过程如下：（1）Redis使用fork函数复制一飞父进程的副本 （2）父进程继续接收并处理客户
	端的命令，子进程将内存中的数据写入硬盘的临时文件 （3）当子进程写入完所有数据后会用该临时文件替换旧的rdb文
	件，整个快照过程完成。

	执行fork时操作戏台会使用写时复制策略，即fork函数发生的一刻父进程共享同一内存数据，当父进程要更改其中某片数
	据时，操作戏台会将该片数据复制一份以保证子进程的数据不受影响，所以rdb文件存储的时执行fork一刻的内存数据。
	
	快照方式由于有时间间隔，所以如果redis异常退出将丢失最后一次快照后更改的所有数据，在使用时要通过组合设置自
	动快照条件的方式来将可能发生的数据损失控制中能接受的范围。

	2.AOF方式，默认情况下没有开启该模式，通过 appendonly 参数开启： appendonly yes
	开启AOF后每执行一条会更改Redis中的数据的命令就会将该命令写入到硬盘的AOF文件，AOF文件的保存位置和RDB文件的
	位置相同，都是根据dir参数设置，默认文件名为appendonly.aof,可以通过appendfilename参数修改：
	appendfilename appendonly.aof

	AOF文件时纯文本文件，内容时Redis客户端向Redis发送的原始通协议的内容。aof文件自动优化有以下配置项：
	auto-aof-rewrite-percentage 100 当目前的AOF文件大小超过上一次重写时AOF文件大小的百分之多少时再次重写，如果
	没有重写过则以启动时的AOF文件大小为依据。
	
	auto-aof-rewrite-min-size 64mb  限制了允许重写的最小AOF文件大小，通常中AOF文件很小时即使其中有很多冗余命令
	我妈也不太关心。

	BGREWRITEAOF命令-- 是哦动执行AOF重写。

	由于操作系统机制AOF方式实际上中每次更改数据时并没有真正的写入硬盘，而是进入了系统的硬盘缓存，中默认情况下
	系统每30秒会执行一次同步操作，将数据写道硬盘中。这序言Redis中写入AOF文件后主动要求系统将缓存内容同步到硬盘
	在Redis中通过appendfsync参数设置同步时机：
	appendfsync everysec --> Redis默认使用了everysec规则，每秒执行一次同步操作。	
	appendfsync always --> 表示每次执行写入都会执行同步，这是最安全也时最慢的方式。
	appendfsync no --> 表示不主动进行同步操作，而是完全交由操作戏台来做，这是最快最不安全的做法。
	一般情况下使用everysec就足够了，兼顾了速度和安全性。

	Redis允许同时开启AOF和RDB，既保证数据安全有使得备份等操作十分容易。此时重启Reids会使用AOF来恢复数据，因为
	AOF方式的持久化可能丢失的数据更少。

		
配置
	同步后的数据库分为两类，一类时主数据库(master)，一类时从数据库(slave)。主数据库科研进行读写操作，当发生写
	操作时自动将数据同步给从数据库。而从数据库一般时只读的，并接受主数据库同步过来的数据。一个主数据库科研拥有
	多个从数据库，而一个从数据库只能拥有一个主数据库。
	
	在Redis中使用复制功能非常容易，只需要从数据库配置文件中加入"slaveof 主数据库ip 主数据库端口"即可，主数据库
	无需进行任何配置。
	
	示例：
	redis-server -->启动一个主数据库
	redis-server --port 6380 --slaveof 127.0.0.1 6379 -->启动一个从数据库，并设定主数据库
	redis-cli --> 启动一个redis客户的实例A
	set foo bar --> 在实例A设置一个键值
	
	redis-cli -p 6380 -->启动一个客户端实例B链接从数据库
	get foo --> 在实例B中获得该值

	但是直接修改从数据库的数据将会报错，如：在B客户的实例中执行set foo hi时将会报错。
	可以通过设置从数据库的配置文件中的slave-read-only为no使从数据库可写，但从数据库的任何更改都不会同步给其他
	数据库，并且主数据库中更新了对应的数据将覆盖从数据库中的改动。
	
	配置多个从数据库只需要中从数据的配置文件中都加上slaveof参数指向同一个主数据库即可。
	除了配置文件或命令行参数设置slaveof参数，还可以中运行时使用slaveof命令修改：
	redis> slaveof 127.0.0.1 6379
	如果该数据库已经时其他数据库的从数据库，slaveof命令会停止和原来的数据库的同步转而和新的数据库同步。还可以
	使用 slaveof no one 来使当前数据库停止接收其他数据库的同步转成主数据库。

	为了提高性能，科研通过复制功能建立一个或多个从数据库，并中从数据库中启用持久化，同时中主数据库禁用持久化，
	当从数据库崩溃重启后主数据库会自动同步数据过去，而当主数据库崩溃时，需要中从数据库中使用 slaveof no one
	命令来将从数据库提升为主数据库继续服务，并中原来的主数据库启动后使用 slaveof 命令将其设置为新的主数据库的
	从数据库，既可以将数据同步过来。

安全
	Redis的安全设计是“Redis运行中可信的环境”这个前提下的，一般不允许外界直接连接Redis服务器而是通过应用服务器
	进行中转，Redis默认情况下时允许任何地址发送请求的，要更改这个设置，可以中配置文件中修改bind参数，如：只允
	许本机链接，可以将bind参数设置为： 
	bind 127.0.0.1
	bind参数只能绑定一个地址，如果向更自由的设置访问规则需要通过防火墙来完成。	

	可以通过配置文件中的requirepass参数为Redis设置一个密码，例如：
	requirepass abc!@#123
	这样客户的每次连接时都需要发送密码，如：
	redis> auth abc!@#123
	redis> get foo  -->如果不先auth发送密码，将会返回错误

	
	

	
	
		
		
	
		










	


